# Author : Eng. Sayed Salem

import numpy as np
from GA_functions import *

equation_inputs = [4, -2, 3.5, 5, -11, -4.7]
num_weights = len(equation_inputs)
sol_per_pop = 8
pop_size = (sol_per_pop, num_weights)
new_population = np.random.uniform(low=-3.0, high=3.0, size=pop_size)
number_parents_mating = 4

outputs = []
num_generations = 1000
for generation in range(num_generations):

    print('Generation : \n',new_population)

    #calculating the fitness of each chromosome in the population.
    fitness_values=fitness(new_population,equation_inputs)
    print('Fitness : ',fitness_values)

    #calculating the best value of the fitness function in the current iteration
    outputs.append(np.max(fitness_values))
    print(f"The best result of the current iteration No. {generation+1} : " ,np.max(fitness_values))


    #selecting the parents from the best results in the current iteration
    parents = parents_selection(fitness_values,new_population,number_parents_mating)
    print("Parent : \n",parents)


    #generating the offspring of the next generation
    offspring = crossover(parents,(pop_size[0]-number_parents_mating,num_weights))
    print("offspring : \n",offspring)

    #making some variations to the offsprint of the next generation using mutation
    offspring_mutation = mutation(offspring,2)
    print('offspring mutation : \n',offspring_mutation)

    #creating a new population of the next generation from the parents and the offspring of the current generation
    new_population[:number_parents_mating,:]= parents  # save the parents in the new_generation array !!
    new_population[number_parents_mating:,:]=offspring_mutation
    print('new_generation : \n',new_population)

print("After 1000 generation this is the final result : \n")
final_fitness=fitness(new_population,equation_inputs)
print("Best Solution : \n",np.max(final_fitness))

print("This solution is generated by these parameters :\n ",new_population[np.argmax(final_fitness),:])

output_results(outputs)
