import numpy as np
from problem_functions import *

number_solu = 8
number_parents = 4

population = init_population(number_solu)
mx_fit = -99999999999
penalties = []
mx_pop=np.random.randint(8,size=8)
iterations = 10000
for iter in range(iterations):

    print('Generation : \n', population)

    # calculating the fitness of each chromosome in the population.
    fitness_values = fitness(population)
    print('Fitness : ', fitness_values)

    # calculating the best value of the fitness function in the current iteration
    max_fitness_idx = np.argmax(fitness_values)
    penalties.append(fitness_values[max_fitness_idx])
    print(f"The best result of the current iteration No. {iter + 1} : ", fitness_values[max_fitness_idx])
    if fitness_values[max_fitness_idx] > mx_fit:
        mx_fit = fitness_values[max_fitness_idx]
        mx_pop = population[max_fitness_idx].copy()
    # selecting the parents from the best results in the current iteration
    parents = parents_selection(population, fitness_values, number_parents)
    print("Parent : \n", parents)

    # generating the offspring of the next generation
    pc = 0.70
    offspring = crossover(parents, (number_solu - number_parents, 8), pc)
    print("offspring : \n", offspring)

    # making some variations to the offsprint of the next generation using mutation
    offspring_mutation = mutation(offspring, 2)
    print('offspring mutation : \n', offspring_mutation)

    # creating a new population of the next generation from the parents and the offspring of the current generation
    population[:number_parents, :] = parents  # save the parents in the new_generation array !!
    population[number_parents:, :] = offspring_mutation
    print('new_generation : \n', population)

print("After 1000 generation this is the final result : \n")
print("Best Solution with lower penalty : ", mx_fit)

print("This solution is generated by these parameters : ", mx_pop)

output_results(penalties)
